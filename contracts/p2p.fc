#pragma version >=0.4.0;

#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/op-codes.fc";
#include "imports/utils.fc";

global int init?;
;; global int storage::index; ;; if sbt not single
global int request?;

global slice storage::arbitrator_address;

global slice storage::lessor_address;
global slice storage::renter_address;

global cell storage::content;

global int storage::cost;
global int storage::arbitrator_fee_percent;
global int storage::deposit;

global int storage::rent_time;
global int storage::delay_time;
global int rent_end_time;

global int ended?;


() load_data() impure inline {
    slice ds = get_data().begin_parse();

    init? = false;
    ended? = false;
    request? = false;
    storage::arbitrator_address = ds~load_msg_addr();
    storage::lessor_address = ds~load_msg_addr();
    storage::renter_address = ds~load_msg_addr();

    storage::content = ds~load_ref();

    slice ds2 = ds~load_ref().begin_parse();
    storage::cost = ds2~load_coins();
    storage::arbitrator_fee_percent = ds2~load_coins();
    storage::rent_time = ds2~load_uint(32);
    if(ds2.slice_bits()) {
        init? = true;
        storage::deposit = ds2~load_coins();
        storage::delay_time = ds2~load_uint(32);
        rent_end_time = ds2~load_uint(32);
        request? = ds2~load_int(1);
        ended? = ds2~load_int(1);
    }
}

() save_data() impure inline {
    set_data(
        begin_cell()                                        ;; 267 + 267 + 267 = 801b ;; refs = 2
            .store_slice(storage::arbitrator_address)
            .store_slice(storage::lessor_address)
            .store_slice(storage::renter_address)
            .store_ref(storage::content)
            .store_ref(                                     ;; 124 + 124 + 32 + 124 + 32 + 32 + 1 + 1 = 470b ;; refs = 0
                begin_cell()
                    .store_coins(storage::cost)
                    .store_coins(storage::arbitrator_fee_percent)
                    .store_uint(storage::rent_time, 32)
                    .store_coins(storage::deposit)
                    .store_uint(storage::delay_time, 32)
                    .store_uint(rent_end_time, 32)
                    .store_int(request?, 1)
                    .store_int(ended?, 1)
                .end_cell()
            )
        .end_cell()                                         ;; total bits 801 + ^470 = 1271 ;; total refs = 2
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if(in_msg_body.slice_empty?()) {
        return();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    int fwd_fee_from_in_msg = cs~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(WORKCHAIN, fwd_fee_from_in_msg);

    if(flags & 1) {
        return();
    }

    load_data();

    int op = in_msg_body~load_uint(32);
    int query_id = slice_bits(in_msg_body) >= 64 ? in_msg_body~load_uint(64) : 0;

    ;; try {

        if(op == op::comment_message) {
            throw_if(err::finished, ended?);

            int comment = string_hash(in_msg_body);
            if(comment == "Deposit"H) {
                throw_unless(err::wrong_deposit, msg_value == deposit_size + gas::transaction);
                throw_unless(err::unauthorized_access, equal_slices(sender_address, storage::renter_address));
                throw_if(err::already_inited, init?);

                storage::deposit = msg_value - gas::transaction;
                rent_end_time = now() + storage::rent_time;
                storage::delay_time = 0; 

                send_message_with_comment(flags::unbounceable, sender_address, gas::info_value, "Deposit successful", mode::pay_fees_separately);

                init? = true;
                request? = false;
                ended? = false;

                save_data();
                return();
            }

            throw_unless(err::not_inited, init?);

            if(comment == "Cancel"H) { 
                throw_unless(err::unauthorized_access, equal_slices(sender_address, storage::lessor_address) | equal_slices(sender_address, storage::arbitrator_address));
                throw_unless(err::out_of_gas, msg_value >= gas::cancellation);
                throw_if(err::request_sent, request?); ;; consider finished rent

                slice who_canceled? = equal_slices(sender_address, storage::lessor_address) ? "Lessor canceled rent" : "Arbitrator canceled rent";

                send_message_with_comment(flags::unbounceable, storage::renter_address, storage::deposit, who_canceled?, mode::pay_fees_separately);
                send_message_with_comment(flags::unbounceable, storage::lessor_address, gas::info_value, who_canceled?, mode::pay_fees_separately);
                send_message_with_comment(flags::unbounceable, storage::arbitrator_address, 0, who_canceled?, mode::carry_remaining_balance);

                ended? = true;
                save_data();

                return();
            }

            if(comment == "Finish"H) {
                throw_unless(err::unauthorized_access, equal_slices(sender_address, storage::lessor_address));
                throw_unless(err::out_of_gas, msg_value >= gas::transaction);
                throw_unless(err::not_finished, now() >= rent_end_time);
                
                storage::delay_time = rent_end_time + one_hour;
                ;; send payment request
                send_cell_message(storage::renter_address, gas::info_value, begin_cell().store_uint(0, 32).store_slice("Send ").store_str_float(storage::cost, nano).store_slice(" ðŸ’Ž with 'Payment' comment ").end_cell(), mode::pay_fees_separately);

                request? = true;
                save_data();
                return();
            }

            if(comment == "Payment"H) {
                throw_unless(err::not_enough_money, msg_value == storage::cost);
                throw_unless(err::unauthorized_access, equal_slices(sender_address, storage::renter_address));
                throw_unless(err::not_finished, now() >= rent_end_time);
                throw_unless(err::request_not_sent, request?);

                int now = now();
                int arbitrator_fee = muldiv(storage::cost, storage::arbitrator_fee_percent, percent_divisor);
                int value_to_send = storage::cost - arbitrator_fee;

                if(now > storage::delay_time) {
                    ;; w/penalty
                    send_message_with_comment(flags::unbounceable, storage::arbitrator_address, arbitrator_fee, "Arbitrator fee", mode::pay_fees_separately);
                    send_message_with_comment(flags::unbounceable, storage::lessor_address, value_to_send + storage::deposit, "Money for rent + deposit as fine", mode::pay_fees_separately);
                    send_message_with_comment(flags::unbounceable, storage::renter_address, gas::info_value, "Payment was delayed", mode::pay_fees_separately);
                }
                else {
                    ;; w/o penalty
                    send_message_with_comment(flags::unbounceable, storage::arbitrator_address, arbitrator_fee, "Arbitrator fee", mode::pay_fees_separately);
                    send_message_with_comment(flags::unbounceable, storage::lessor_address, value_to_send, "Money for rent", mode::pay_fees_separately);
                    send_message_with_comment(flags::unbounceable, storage::renter_address, storage::deposit, "Deposit return", mode::pay_fees_separately);
                }

                ended? = true;
                save_data();

                return();
            }

            ;; arbitrator methods
            throw_unless(err::unauthorized_access, equal_slices(sender_address, storage::arbitrator_address));
            if(comment == "Abort"H) {
                throw_unless(err::renter_has_time, now() >= storage::delay_time);
                throw_unless(err::request_not_sent, request?); ;; if request sent, but renter did not send the payment
                throw_unless(err::out_of_gas, msg_value >= gas::cancellation);

                send_message_with_comment(flags::unbounceable, storage::renter_address, gas::info_value, "Renter did not send payment. Rent aborted.", mode::pay_fees_separately);
                send_message_with_comment(flags::unbounceable, storage::lessor_address, storage::deposit, "Renter did not send payment. Rent aborted.", mode::pay_fees_separately);
                send_message_with_comment(flags::unbounceable, storage::arbitrator_address, 0, "Renter did not send payment. Rent aborted.", mode::carry_remaining_balance);

                ended? = true;
                save_data();

                return();
            }

            if(comment == "Pause"H) {
                return();
            }
            if(comment == "Unpause"H) {
                return();
            }

            return();
        }

        ;;  if(op == op::withdraw_tons) {
        ;;         throw_unless(err::unauthorized_access, equal_slices(sender_address, storage::arbitrator_address));
        ;;         throw_unless(err::out_of_gas, msg_value >= gas::transaction);

        ;;         raw_reserve(gas::min_for_storage, 0);

        ;;         var msg = begin_cell()
        ;;                     .store_uint(flags::unbounceable, 6)
        ;;                     .store_slice(storage::arbitrator_address)
        ;;                     .store_coins(0)
        ;;                     .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 32)
        ;;                     .store_slice("Tons successfully withdrawn!");

        ;;         send_raw_message(msg.end_cell(), mode::carry_remaining_balance + mode::ignore_errors);

        ;;         return();            
        ;;     }

        throw(op::unknown);

    ;; } catch (_, n) {
    ;;     send_cell_message(sender_address, 0, begin_cell().store_uint(0, 32).store_slice("Error. Code ").store_number10(n).end_cell(), mode::carry_remaining_gas);
    ;;     return();
    ;; }

}


{- GET -}

(int, int, slice, slice, cell) get_nft_data() method_id {
    load_data();
    ifnot(null?(storage::content)) {
        slice content_cs = storage::content.begin_parse();
        cell loaded_dict = content_cs~load_ref();

        int rent_time_days = storage::rent_time / one_day;
        var (_, r) = divmod(storage::rent_time, one_day);
        int rent_time_hours = r / one_hour;

        ;; (slice uri, int success) = loaded_dict.udict_get?(256, "uri"H); ;; no need now
        ;; if (success) {
        ;;     uri = uri~load_ref().begin_parse();
        ;;     loaded_dict~udict_set(256, "uri"H, begin_cell().store_ref(begin_cell().store_slice(uri).store_number10(storage::index).end_cell()).end_cell().begin_parse());
        ;; }

        (slice item_name_slice, int success) = loaded_dict~udict_delete_get?(256, "item_name"H);
        builder sbt_name = begin_cell();
        if(success) {
            sbt_name.store_uint(0, 8).store_slice(item_name_slice).store_slice(" rental");
        } else {
            sbt_name.store_uint(0, 8).store_slice("Rent");
        }

        if (ended?) {
            sbt_name.store_slice(" (ended)");
        }

        builder sbt_description = begin_cell();

        if(~ init?) {
            sbt_description.store_slice("Waiting for deposit...ðŸ’¸");
        } else {
            sbt_description.store_uint(0, 8)  ;; snake format prefix
            .store_slice("Cost: ")
            .store_str_float(storage::cost, nano)
            .store_uint(10, 8)
            .store_slice("Rent time: ")
            .store_number10(rent_time_days)
            .store_uint(32, 8)
            .store_slice(" day(s) ")
            .store_number10(rent_time_hours)
            .store_slice(" hours");
                                    
            builder sbt_description_ref = begin_cell()
                                    .store_uint(10, 8)
                                    .store_slice("Rent end timestamp: ")
                                    .store_number10(rent_end_time)
                                    .store_uint(10, 8)
                                    .store_slice("Arbitrator percent: ")
                                    .store_str_float(storage::arbitrator_fee_percent, nano)
                                    .store_uint(37, 8);

            sbt_description = sbt_description.store_ref(sbt_description_ref.end_cell());
        }

        loaded_dict~udict_set(256, "name"H, begin_cell().store_ref(sbt_name.end_cell()).end_cell().begin_parse());
        loaded_dict~udict_set(256, "description"H, begin_cell().store_ref(sbt_description.end_cell()).end_cell().begin_parse());
        
        return (init?, 0, null_addr(), storage::lessor_address, begin_cell().store_uint(0, 8).store_dict(loaded_dict).end_cell());
    }
    return (init?, 0, null_addr(), storage::lessor_address, storage::content);
}

slice get_editor() method_id {
    load_data();
    return null_addr();
}

slice get_authority_address() method_id {
    load_data();
    return null_addr();
}

int get_revoked_time() method_id {
    return 0;
}
;; 1      2      3      4     5    6    7    8    9   10   11   12   13
(int, slice, slice, slice, cell, int, int, int, int, int, int, int, int) get_storage() method_id {
    load_data();
    if(~ init?) {
        return(
            init?,                              ;; 1
            storage::arbitrator_address,        ;; 2
            storage::lessor_address,            ;; 3
            storage::renter_address,            ;; 4
            storage::content,                   ;; 5
            storage::cost,                      ;; 6
            storage::arbitrator_fee_percent,    ;; 7
            0, 0, 0, 0, 0, 0
;;          8  9  10 11 12 13
        );
    } else {
        return(
            init?,                              ;; 1
            storage::arbitrator_address,        ;; 2
            storage::lessor_address,            ;; 3
            storage::renter_address,            ;; 4
            storage::content,                   ;; 5
            storage::cost,                      ;; 6
            storage::arbitrator_fee_percent,    ;; 7
            storage::deposit,                   ;; 8
            storage::rent_time,                 ;; 9
            storage::delay_time,                ;; 10
            rent_end_time,                      ;; 11
            request?,                           ;; 12
            ended?                              ;; 13
        );
    }
}